#include<stdio.h>
int main(void) {

	char arr[3][6] = { { "APPLE\n" },{ "GRAPE\n" },{ "MANGO\0" } }; //2차원 배열에 각각 문자열들 초기화
	char *p;  //캐릭터형 포인터 p 선언
	char **pp; //캐릭터형 포인터를 가리키는 이중 포인터 pp선언
	int i;  //for문을위한 i 선언

	int a = 10; //int형 변수 a 선언후 10으로초기화
	printf("%d %d %d\n", a++, ++a, ++a); //전위 연산자 두번은 실행 전에 연산해줘야하니 a++을 두번 해주면 12로 시작, 후위 연산자 한번이라 12출력,그뒤는 1더해줬으니 13 13출력..a=13끝
	printf("%d %d %d\n", a++, --a, a--); //전위 연산자 한번 있으므로 a=13에서 a=12로 시작, 앞부터 a++ 출력시 12, 12->13됐고  네,이쪽 줄은 정말 모르겠습니다.
	
	p = &arr[0][0]; //포인터 p가 arr[0][0] 즉 첫번째 배열의 주소를 가리키게 함.
	pp = &p; // 이중포인터 pp가 포인터 p를 가리키게 함

	for (i = 0; i<18; i++) {
		printf("%c", *p); //이차원 배열의 값들을 일일이 모두 출력 p++하면 p=&a[0][1] 가 되고 이런식으로..
		p++;
	}
	p = p - 12; //지금 마지막 반복후 p[2][5]의 다음 주소까지 와있는데(char : 1byte다.) 12만큼 다시 감소 시키면 p=&arr[1][0] , 즉 GRAPE의 G 가리킴
	printf("\n%c\n", *p);//G출력
	

	printf("%c\n", *((*pp) + 2)); //*pp면 p인데 p+2에 포인터 씌워주면 *(p+2) => GRAPE의 A 출력
	printf("%c\n", **pp); //앞 연산에서 p는 건들지 않았으므로 아직p가 가리키는 주소값은 변하지 않았고 , **pp는 pp가 가리키는 포인터가 가리키는값, *(*pp) 즉 *p 말하는것이다. 
	
	*pp = (*pp) + 3; //지금 (*pp)에 3을 더했으니 p+3 해주면 G를 가리키던 p는 GRAPE의 P를 가리키게 됨.
	//printf("%c%c%c%c", *(*pp++), *(*pp + 4), *(*pp - 5), **pp); //일단 첫번째는 후위연산자니까 먼저 *(*pp)를 출력하면 P를 출력함. 그런데 연산자 우선순위를 보면 이중포인터 pp의 주소를증가시킨것이라
	printf("%d\n", pp);										//뒤의 연산들은 의미가 없음 이제 이중 포인터 pp는 자신의 주소값이 증가되어 포인터 p를 가리키지 않음.
	printf("%c\n", *(*pp++));
	printf("%d\n", pp);
	return 0;
}
//★잘못두번째는 *pp에 4더했으니 P에서 4번 뛰어넘은 A 출력함. 세번쨰는 *pp에 -5를 해줬으니 P에서 뒤로 5번 뛰어넘은E를 출력함, 그리고 마지막 **pp P출력 마무리.

/*
a p p l e \n
g r a p e \n
m a n g o \n*/